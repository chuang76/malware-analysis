import struct 
import string 
from idc import *

VALID_CHARACTERS = [ord(c) for c in string.printable]

def get_addr(name):
    section_start = get_segm_by_sel(selector_by_name(name))
    section_end = get_segm_end(section_start)
    return section_start, section_end

def xor_decrypt(key, data):
    decrypted_data = []
    for i in range(len(data)):
        decrypted_byte = data[i] ^ key[i % len(key)]
        decrypted_data.append(decrypted_byte)
    
    return bytes(decrypted_data)

def is_invaid_str(s):
    for c in s:
        if c not in VALID_CHARACTERS:
            return True
    return False 

def sanitize_str(s):
    s = s.decode()
    for c in "\t\r\n":
        s = s.replace(c, '_')
    return s 
    
def decrypt_str(section_start, section_end):

    for offset in range(section_start, section_end - 8, DWORD_SIZE):
        
        xor_key = get_wide_dword(offset)
        data_len = xor_key ^ get_wide_dword(offset + DWORD_SIZE)
        
        # too large 
        if data_len > 400 or (offset + 8 + data_len) > section_end:        
            continue 
        
        aligned_len = (data_len + 3) & 0xFFFFFFFC
        
        decrypted_data = b''
        for i in range(8, aligned_len + 8, DWORD_SIZE):
            decrypted_dword = get_wide_dword(offset + i) ^ xor_key 
            decrypted_dword = struct.pack('<I', decrypted_dword)
            decrypted_data += decrypted_dword
            
        decrypted_data = decrypted_data[:data_len]
        
        if is_invaid_str(decrypted_data) or len(decrypted_data) < 3:
            continue 
        
        print("[+] decrypted_data = {}".format(decrypted_data))
        comment = sanitize_str(decrypted_data)
        set_cmt(offset, comment, 1)

def main():
    
    section_start, section_end = get_addr('.text')
    decrypt_str(section_start, section_end)
    
if __name__ == '__main__':
    main()